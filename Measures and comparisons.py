# -*- coding: utf-8 -*-
"""biof.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UZHsw6H-fnpfGD-e_i76LS0o45vxpbE6
"""

#Librerias usadas para realizar las comparaciones

import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
import scipy as sp 
from scipy import stats as st
import math 
from scipy.optimize import fsolve
import pandas as pd
import statistics

#Grafos para mujeres en todos los consensos
Female_1 = nx.read_graphml("Female 1.graphml")
Female_10 = nx.read_graphml("Female 10.graphml")
Female_20 = nx.read_graphml("Female 20.graphml")
Female_30 = nx.read_graphml("Female 30.graphml")
Female_40 = nx.read_graphml("Female 40.graphml")
Female_50 = nx.read_graphml("Female 50.graphml")
Female_60 = nx.read_graphml("Female 60.graphml")
Female_70 = nx.read_graphml("Female 70.graphml")
Female_80 = nx.read_graphml("Female 80.graphml")
Female_90 = nx.read_graphml("Female 90.graphml")
Female_100 = nx.read_graphml("Female 100.graphml")

#Grafos para hombres en todos los consensos
Male_1 = nx.read_graphml("Male 1.graphml")
Male_10 = nx.read_graphml("Male 10.graphml")
Male_20 = nx.read_graphml("Male 20.graphml")
Male_30 = nx.read_graphml("Male 30.graphml")
Male_40 = nx.read_graphml("Male 40.graphml")
Male_50 = nx.read_graphml("Male 50.graphml")
Male_60 = nx.read_graphml("Male 60.graphml")
Male_70 = nx.read_graphml("Male 70.graphml")
Male_80 = nx.read_graphml("Male 80.graphml")
Male_90 = nx.read_graphml("Male 90.graphml")
Male_100 = nx.read_graphml("Male 100.graphml")

#Vectores en donde se almacenan cada uno de los grafos para hombres y mujeres
Males = [Male_1,Male_10,Male_20,Male_30,Male_40,Male_50,Male_60,Male_70,Male_80,Male_90,Male_100]
Females = [Female_1,Female_10,Female_20,Female_30,Female_40,Female_50,Female_60,Female_70,Female_80,Female_90,Female_100]

#Comando para remover cada uno de los nodos que se encuentran isolados en la red
def remove_isolates(Grafo):
  isolados = list(nx.isolates(Grafo))
  Grafo.remove_nodes_from(isolados)
  return Grafo

for grafo in Males:
  remove_isolates(grafo) 
for grafo in Females:
  remove_isolates(grafo)
for grafo in Humans:
  remove_isolates(grafo)

#Vectores para introducir los grafos isolados
MalesC=[]
FemaleC=[]

#Comandos utilizados para extraer la componente con más nodos en las redes
for i in Males:
  a=sorted(nx.connected_components(i), key=len, reverse=True)
  MalesC.append(i.subgraph(a[0]))
for i in Females:
  a=sorted(nx.connected_components(i), key=len, reverse=True)
  FemaleC.append(i.subgraph(a[0]))

qq=max(nx.connected_components(Male_90), key=len)
print(len(qq))
print(len(Male_90.nodes()))

#Comando para calcular los valores de clusterización promedio de cada grafo
edges_males = []
edges_females = []
edges_humans= []

for i in MalesC:
  edges_males.append(nx.average_clustering(i))
for i in FemaleC:
  edges_females.append(nx.average_clustering(i))


PP=[1,10,20,30,40,50,60,70,80,90,100]

#Comando para graficar los valores de clusterización promedio de cada grafo

plt.plot(PP,edges_males,color='red',label='Hombres')
plt.plot(PP,edges_females,color='blue',label='Mujeres')
plt.legend(loc=3)
plt.plot (dpi = 300)
plt.title('Coeficiente de Clusterización')
plt.xlabel('Eje mínimo de confidencia')
plt.ylabel('Clusterización')

#Comando para calcular las diferencias de valores de clusterización promedio de cada grafo

DifClust=[]
for i in range(len(PP)):
  a=statistics.mean([edges_males[i],edges_females[i]])
  DifClust.append((edges_females[i]-edges_males[i])/a)

b=0
for i in range(len(DifClust)):
  b=b+DifClust[i]

print(b," Suma de diferencias en clusterización")

plt.plot(PP,DifClust,color='red')
plt.legend(loc=3)
plt.plot (dpi = 300)
plt.title('Diferencias Normalizadas Clusterización')
plt.xlabel('Eje mínimo de confidencia')
plt.ylabel('Diferencia Presentada')

#Comando para calcular los valores de centralidad de grado promedio de cada grafo
DegreeC_M=[]
DegreeC_F=[]
DegreeC_H=[]
for i in Males:
  DegreeC_M.append(statistics.mean(list(nx.degree_centrality(i).values())))
for i in Females:
  DegreeC_F.append(statistics.mean(list(nx.degree_centrality(i).values())))
for i in Humans:
  DegreeC_H.append(statistics.mean(list(nx.degree_centrality(i).values())))

#Comando para graficar los valores de centralidad de grado promedio de cada grafo
plt.plot(PP,DegreeC_M,color='red',label='Hombres')
plt.plot(PP,DegreeC_F,color='blue',label='Mujeres')
plt.plot(PP,DegreeC_H,color='green',label='Humanos')
plt.legend(loc=1)
plt.title('Centralidad de grado promedio')
plt.xlabel('Eje mínimo de confidencia')
plt.ylabel('Centralidad de grado')

#Comando para calcular los valores de centralidad de eigenvector promedio de cada grafo
DegreeE_M=[]
DegreeE_F=[]
DegreeE_H=[]
for i in MalesC:
  DegreeE_M.append(statistics.mean(list(nx.eigenvector_centrality(i,200).values())))
for i in FemaleC:
  DegreeE_F.append(statistics.mean(list(nx.eigenvector_centrality(i,200).values())))

#Comando para graficar los valores de centralidad de eigenvector promedio de cada grafo
plt.plot(PP,DegreeE_M,color='red',label='Hombres')
plt.plot(PP,DegreeE_F,color='blue',label='Mujeres')
plt.legend(loc=2)
plt.plot (dpi = 300)
plt.title('Centralidad de Eigenvector Promedio')
plt.xlabel('Eje Mínimo de Confidencia')
plt.ylabel('Centralidad Eigenvector')

#Comando para calcular las diferencias de los valores de centralidad de eigenvector promedio de cada grafo

DifEing=[]
for i in range(len(PP)):
  a=statistics.mean([DegreeE_M[i],DegreeE_F[i]])
  DifEing.append((DegreeE_F[i]-DegreeE_M[i])/a)

b1=0
for i in range(len(DifEing)):
  b1=b1+DifEing[i]

print(b1," Suma de diferencias en Eigenvector")

plt.plot(PP,DifEing,color='red')
plt.legend(loc=3)
plt.plot (dpi = 300)
plt.title('Diferencias Normalizadas Centralidad Eigenvector')
plt.xlabel('Eje mínimo de confidencia')
plt.ylabel('Diferencia Presentada')

#Comando para calcular los valores del grado promedio de cada grafo

DegreeD_M=[]
DegreeD_F=[]
DegreeD_H=[]

A=nx.degree(Male_100)
print(list(dict(A).values()))

for i in MalesC:
  DegreeD_M.append(statistics.mean(list(dict(nx.degree(i)).values())))
for i in FemaleC:
  DegreeD_F.append(statistics.mean(list(dict(nx.degree(i)).values())))

#Comando para graficas los valores del grado promedio de cada grafo

plt.plot(PP,DegreeD_M,color='red',label='Hombres')
plt.plot(PP,DegreeD_F,color='blue',label='Mujeres')
plt.legend(loc=1)
plt.plot (dpi = 300)
plt.title('Grado Promedio de la Red')
plt.xlabel('Eje Mínimo de Confidencia')
plt.ylabel('Grado Promedio')

#Comando para calcular las diferencias de los valores del grado promedio de cada grafo

DifGProm=[]
for i in range(len(PP)):
  a=statistics.mean([DegreeD_M[i],DegreeD_F[i]])
  DifGProm.append((DegreeD_F[i]-DegreeD_M[i])/a)

b2=0
for i in range(len(DifGProm)):
  b2=b2+DifGProm[i]

print(b2," Suma de diferencias en Eigenvector")  

plt.plot(PP,DifGProm,color='red')
plt.legend(loc=3)
plt.plot (dpi = 300)
plt.title('Diferencias Normalizadas Grado Promedio')
plt.xlabel('Eje mínimo de confidencia')
plt.ylabel('Diferencia Presentada')

#Comando para calcular los valores del betweenness promedio de cada grafo

DegreeB_M=[]
DegreeB_F=[]
DegreeB_H=[]

a=nx.betweenness_centrality(Human_1)

for i in Males:
  DegreeB_M.append(statistics.mean(list(nx.betweenness_centrality(i).values())))
for i in Females:
  DegreeB_F.append(statistics.mean(list(nx.betweenness_centrality(i).values())))
for i in Humans:
  DegreeB_H.append(statistics.mean(list(nx.betweenness_centrality(i).values())))

#Comando para graficar los valores del betweenness promedio de cada grafo

plt.plot(PP,DegreeB_M,color='red',label='Hombres')
plt.plot(PP,DegreeB_F,color='blue',label='Mujeres')
plt.plot(PP,DegreeB_H,color='green',label='Humanos')
plt.legend(loc=2)
plt.title('Betweenness Promedio de la Red')
plt.xlabel('Eje Mínimo de Confidencia')
plt.ylabel('Betweenness')

#Comando para calcular los valores del closeness promedio de cada grafo

DegreeCL_M=[]
DegreeCL_F=[]
DegreeCL_H=[]


for i in Males:
  DegreeCL_M.append(statistics.mean(list(nx.closeness_centrality(i).values())))
for i in Females:
  DegreeCL_F.append(statistics.mean(list(nx.closeness_centrality(i).values())))
for i in Humans:
  DegreeCL_H.append(statistics.mean(list(nx.closeness_centrality(i).values())))

#Comando para graficar los valores del closeness promedio de cada grafo

plt.plot(PP,DegreeCL_M,color='red',label='Hombres')
plt.plot(PP,DegreeCL_F,color='blue',label='Mujeres')
plt.plot(PP,DegreeCL_H,color='green',label='Humanos')
plt.legend(loc=3)
plt.title('Closeness Centralidad promedio')
plt.xlabel('Eje Mínimo de Confidencia')
plt.ylabel('Closeness')

#Comando para graficar los valores de la cantidad de nodos de cada grafo

plt.plot(PP,DegreeNN_M,color='red',label='Hombres')
plt.plot(PP,DegreeNN_F,color='blue',label='Mujeres')
plt.legend(loc=3)
plt.plot (dpi = 300)
plt.title('Numero de Nodos')
plt.xlabel('Eje Mínimo de Confidencia')
plt.ylabel('Cantidad de Nodos')

#Comando para calcular los valores de transitividad promedio de cada grafo

DegreeTR_M=[]
DegreeTR_F=[]
DegreeTR_H=[]

for i in MalesC:
  DegreeTR_M.append(nx.transitivity(i))
for i in FemaleC:
  DegreeTR_F.append(nx.transitivity(i))

#Comando para graficar los valores de transitividad promedio de cada grafo

plt.plot(PP,DegreeTR_M,color='red',label='Hombres')
plt.plot(PP,DegreeTR_F,color='blue',label='Mujeres')
plt.legend(loc=3)
plt.plot (dpi = 300)
plt.title('Medida de Transitividad')
plt.xlabel('Eje Mínimo de Confidencia')
plt.ylabel('Transitividad')

#Comando para calcular las diferencias de los valores de transitividad promedio de cada grafo

DifTm=[]
for i in range(len(PP)):
  a=statistics.mean([DegreeTR_M[i],DegreeTR_F[i]])
  DifTm.append((DegreeTR_F[i]-DegreeTR_M[i])/a)

b3=0
for i in range(len(DifTm)):
  b3=b3+DifTm[i]

print(b3)

plt.plot(PP,DifTm,color='red')
plt.legend(loc=3)
plt.plot (dpi = 300)
plt.title('Diferencias Normalizadas Transitividad')
plt.xlabel('Eje mínimo de confidencia')
plt.ylabel('Diferencia Presentada')

#Comando para calcular los valores de la distancia geodesica promedio y graficarla en cada grafo

DegreeDGP_M=[]
DegreeDGP_F=[]
DegreeDGP_H=[]

for i in MalesC:
  DegreeDGP_M.append(nx.average_shortest_path_length(i))
for i in FemaleC:
  DegreeDGP_F.append(nx.average_shortest_path_length(i))


plt.plot(PP,DegreeDGP_M,color='red',label='Hombres')
plt.plot(PP,DegreeDGP_F,color='blue',label='Mujeres')
plt.legend(loc=3)
plt.plot (dpi = 300)
plt.title('Distancia Geodesica Promedio Sobre el Grafo')
plt.xlabel('Eje Mínimo de Confidencia')
plt.ylabel('Distancia Geodesica Promedio')

#Comando para calcular las deiferencias de los valores de la distancia geodesica promedio de cada grafo

DifGEO=[]
for i in range(len(PP)):
  a=statistics.mean([DegreeDGP_M[i],DegreeDGP_F[i]])
  DifGEO.append((DegreeDGP_F[i]-DegreeDGP_M[i])/a)

b5=0
for i in range(len(DifGEO)):
  b5=b5+DifGEO[i]

print(b5)

plt.plot(PP,DifGEO,color='red')
plt.legend(loc=3)
plt.plot (dpi = 300)
plt.title('Diferencias Normalizadas de Geodésica Promedio')
plt.xlabel('Eje mínimo de confidencia')
plt.ylabel('Diferencia Presentada')

#Comando para calcular los valores del número de ejes de cada grafo

DegreeNGG_M=[]
DegreeNGG_F=[]
DegreeNGG_H=[]

for i in MalesC:
  DegreeNGG_M.append(i.number_of_edges())
for i in FemaleC:
  DegreeNGG_F.append(i.number_of_edges())


plt.plot(PP,DegreeNGG_M,color='red',label='Hombres')
plt.plot(PP,DegreeNGG_F,color='blue',label='Mujeres')
plt.legend(loc=3)
plt.plot (dpi = 300)
plt.title('Número de Conexiones Entre Nodos')
plt.xlabel('Eje Mínimo de Confidencia')
plt.ylabel('Número de Ejes')

#Comando para calcular las diferencias de los valores del numero de ejes de cada grafo
DifNDN=[]
for i in range(len(PP)):
  a=statistics.mean([DegreeNGG_M[i],DegreeNGG_F[i]])
  DifNDN.append((DegreeNGG_F[i]-DegreeNGG_M[i])/a)

plt.plot(PP,DifNDN,color='red')
plt.legend(loc=3)
plt.plot (dpi = 300)
plt.title('Diferencias Normalizadas del Número de Ejes')
plt.xlabel('Eje mínimo de confidencia')
plt.ylabel('Diferencia Presentada')

#Comando para calcular los valores de pequeño mundo promedio de cada grafo

DegreePM_M=[]
DegreePM_F=[]
Degree_H=[]

for i in range(len(PP)):
  DegreePM_M.append(edges_males[i]/DegreeDGP_M[i])
for i in range(len(PP)):
  DegreePM_F.append(edges_females[i]/DegreeDGP_F[i])


plt.plot(PP,DegreePM_M,color='red',label='Hombres')
plt.plot(PP,DegreePM_F,color='blue',label='Mujeres')
plt.plot (dpi = 300)
plt.legend(loc=3)
plt.title('Medida de Pequeño Mundo por Consenso')
plt.xlabel('Eje Mínimo de Confidencia')
plt.ylabel('Medida de Pequeño Mundo')

#Comando para calcular las diferencias de los valores de pequeño mundo promedio de cada grafo

DifPM=[]
for i in range(len(PP)):
  a=statistics.mean([DegreePM_M[i],DegreePM_F[i]])
  DifPM.append((DegreePM_F[i]-DegreePM_M[i])/a)

B6=0
for i in range(len(DifPM)):
  B6=B6+DifPM[i]

print(B6)

plt.plot(PP,DifPM,color='red')
plt.legend(loc=3)
plt.plot (dpi = 300)
plt.title('Diferencias Normalizadas de PMdésica Promedio')
plt.xlabel('Eje mínimo de confidencia')
plt.ylabel('Diferencia Presentada')